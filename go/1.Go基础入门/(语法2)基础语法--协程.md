# Go使用指南--基础语法

> Auth: 王海飞
>
> Data：2019-08-03
>
> Email：779598160@qq.com
>
> github：https://github.com/coco369/knowledge

### 前言

​	**进程、线程 和 协程 之间概念的区别**, 对于 **进程、线程**，都是有内核进行调度，有 CPU 时间片的概念，进行 **抢占式调度**（有多种调度算法）。而对于 **协程**(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 **协作式调度**，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。

​	由于Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。

​	协程的优势：协程在切换开销方面，goroutine 远比线程小消耗小。且协程默认占用内存远比 Java 、C 的线程少。

### 1. 协程定义，go关键字的使用

如下定义add方法，主函数main中通过调用add方法前加go来执行协程。

```
package main

import "fmt"

func add(x, y int)  {
   z := x + y
   fmt.Println(z)
}

func main() {
   for i:=0; i<10; i++ {
      go add(i, i)
   }
}
```

如上实例所示，当运行main时，控制台并没有任何打印输出。原因为：main()函数启动了10个goroutine，然后返回，这时程序就退出了，而被启动的执行 Add() 的 goroutine 没来得及执行。我们想要让 main() 函数等待所有 goroutine 退出后再返回



### 2. 互斥锁

​	Mutex 是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。锁变量（属于一种共享内存）来同步协程。

语法1: func (m *sync.Mutex) m.Lock()，表示Lock 方法锁住 m，如果 m 已经加锁，则阻塞直到 m 解锁。

语法2: func (m *sync.Mutex) m.Unlock()，表示Unlock 方法解锁 m，如果 m 未加锁会导致运行时错误。

优化1中的实例，例子如下：



